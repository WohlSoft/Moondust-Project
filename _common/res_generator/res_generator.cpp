/*
 * RES_Generator - A small resource generator which converts list of files
 * into C++ arrays are can be accessible via friendly functions
 *
 * Copyright (c) 2018-2023 Vitaly Novichkov <admin@wohlnet.ru>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <map>
#include <IniProcessor/ini_processing.h>
#include <utf8main.h>

#ifdef _WIN32
#include <windows.h>
static FILE *utf8_open(const char *path, const char *mode)
{
    wchar_t pathw[MAX_PATH + 1];
    wchar_t modew[MAX_PATH + 1];
    int path_len = strlen(path);
    int mode_len = strlen(mode);
    int pathw_len = MultiByteToWideChar(CP_UTF8, 0, (LPCCH)path, path_len, pathw, MAX_PATH);
    int modew_len = MultiByteToWideChar(CP_UTF8, 0, (LPCCH)mode, mode_len, modew, MAX_PATH);
    pathw[pathw_len] = L'\0';
    modew[modew_len] = L'\0';
    return _wfopen(pathw, modew);
}
#else
#define utf8_open fopen
#endif

static const char *splash = "/*****************************************************************\n"
                            "     Automatically generated by _common/res_generator utility\n"
                            "     Suggested to DONT EDIT THIS\n"
                            "     Edit the _common/res_generator/res_generator.cpp instead\n"
                            " *****************************************************************/\n\n";

struct FileEntry
{
    std::string name;
    std::string path;
    unsigned long size;
};

static int printUsage(char **argv, const char *msg)
{
    printf("%s\n\n"
           "Syntax: %s [--config <ini file name>] <folder that contains \"resource.ini\">\n\n", msg, argv[0]);
    return 1;
}

static int parseTwoArg(const int argc, int &argi, char **argv, const char *key, std::string &out, const char *errmsg)
{
    if(strcmp(argv[argi], key) == 0)
    {
        argi += 1;
        if(argi >= argc)
            return printUsage(argv, errmsg);
        out = argv[argi];
        argi += 1;
        return -1;
    }
    return 0;
}

int main(int argc, char **argv)
{
    IniProcessing ini;

    std::string folderAt = ".";
    std::string iniFile = "resource.ini";
    std::string outputAt = folderAt;
    bool outputWasSet = false;

    std::string headerFile      = "resource.h";
    std::string headerDataFile  = "resource_data.h";
    std::string srcFile         = "resource.cpp";

    fprintf(stdout, "== Starting a Resource Generator == \n\n");
    fflush(stdout);

    if(argc < 2)
        return printUsage(argv, "No path specified!");

    int argi = 1;
    int ret = 0;
    while(argi < argc)
    {
        ret = parseTwoArg(argc, argi, argv, "--config", iniFile, "Missing INI config filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--out-dir", outputAt, "Missing output directory path!");
        if(ret == -1)
        {
            outputWasSet = true;
            continue;
        }
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--header", headerFile, "Missing header filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--data", headerDataFile, "Missing data filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--src", srcFile, "Missing source filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        {
            folderAt = argv[argi];
            if(!outputWasSet)
                outputAt = folderAt;
            argi += 1;
            continue;
        }
    }

    fprintf(stdout, "== INI config name: %s\n", iniFile.c_str());
    fprintf(stdout, "== Output header:   %s\n", headerFile.c_str());
    fprintf(stdout, "== Output data:     %s\n", headerDataFile.c_str());
    fprintf(stdout, "== Output source:   %s\n", srcFile.c_str());
    fprintf(stdout, "== Working folder:  %s\n", folderAt.c_str());
    fprintf(stdout, "== Output folder:   %s\n", outputAt.c_str());
    fflush(stdout);

    ini.open(folderAt + iniFile);
    auto allGroups = ini.childGroups();

    if(allGroups.empty())
    {
        printf("Nothing to do! (zero count)\n");
        return 1;
    }

    std::map<std::string, FileEntry> files;

    for(const auto &key : allGroups)
    {
        std::string name;
        std::string path;

        fprintf(stdout, "== Checking key [%s]...", key.c_str());
        fflush(stdout);

        ini.beginGroup(key);
        {
            if(!ini.hasKey("name") || !ini.hasKey("path"))
            {
                ini.endGroup();
                fprintf(stdout, "INVALID!\n");
                fflush(stdout);
                continue; // Invalid group
            }

            ini.read("name", name, "");
            ini.read("path", path, "");

            fprintf(stdout, "OK!\n");
            fflush(stdout);
        }
        ini.endGroup();

        files.insert({key, {name, folderAt + path, 0}});
    }

    std::string outH     = outputAt + headerFile;
    std::string outHdata = outputAt + headerDataFile;
    std::string outC     = outputAt + srcFile;
    FILE *outh = utf8_open(outH.c_str(), "wb");
    FILE *outd = utf8_open(outHdata.c_str(), "wb");
    FILE *outc = utf8_open(outC.c_str(), "wb");

    if(!outh || !outd || !outc)
    {
        fprintf(stdout, "CAN'T OPEN FILES FOR WRITE\n");
        fflush(stdout);
        return 1;
    }

    fprintf(outc, "%s", splash);
    fprintf(outd, "%s", splash);
    fprintf(outh, "%s", splash);

    fprintf(outc,   "#include <stdio.h>\n"
            "#include <string>\n"
            "#include \"%s\"\n"
            "#include \"%s\"\n"
            "\n",
            headerDataFile.c_str(),
            headerFile.c_str());

    fprintf(outd,   "#include <unordered_map>\n\n"
            "struct FileEntry{\n"
            "    unsigned char*array;\n"
            "    size_t size;\n"
            "};\n\n");

    unsigned long fileCount = 0;
    for(auto &k : files)
    {
        FileEntry &it = k.second;
        fprintf(outd,   "// %s\n"
                "static unsigned char file_%lu[] =\n"
                "{\n    ", it.name.c_str(), fileCount);
        FILE *ps = utf8_open(it.path.c_str(), "rb");
        if(!ps)
        {
            printf("FAILED TO OPEN FILE %s\n", it.path.c_str());
            continue;
        }
        int c;
        int breaker = 0;
        unsigned long fileSize = 0;
        while((c = fgetc(ps)) != -1)
        {
            fprintf(outd, " 0x%02X,", static_cast<unsigned int>(c));
            fileSize++;
            breaker++;
            if(breaker >= 10)
            {
                fprintf(outd, "\n    ");
                breaker = 0;
            }
        }
        fprintf(outd, " 0x00");
        fclose(ps);
        it.size = fileSize;
        fprintf(outd, "\n};\n\n");
        fileCount++;
    }


    fprintf(outd,   "// List of availalbe resource files\n"
            "static std::unordered_map<std::string, FileEntry> filesMap =\n"
            "{\n");
    fileCount = 0;
    for(auto &k : files)
    {
        FileEntry &it = k.second;
        fprintf(outd, "    {\"%s\",\t{file_%lu,%8lu}},\n", it.name.c_str(), fileCount, it.size);
        fileCount++;
    }
    fprintf(outd, "};\n\n");


    fprintf(outc,   "bool RES_getMem(const char* file, unsigned char* &mem, size_t &size)\n{\n"
            "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
            "   if(f == filesMap.end())\n"
            "       return false;\n\n"
            "   FileEntry& e = f->second;\n"
            "   mem = e.array;\n"
            "   size = e.size;\n"
            "   return true;\n"
            "}\n\n");

    fprintf(outh, "#include <stdio.h>\n\n");


    fprintf(outh,   "/**\n"
            " * @brief Get memory pointer and block size to resource file\n"
            " * @param [IN] file name of resource file\n"
            " * @param [OUT] mem reference to null pointer\n"
            " * @param [OUT] size reference to size variable\n"
            " */\n"
            "extern bool RES_getMem(const char* file, unsigned char* &mem, size_t &size);\n\n");

    fclose(outh);
    fclose(outc);

    fprintf(stdout, "\nAll %zu resources has been packed!\n\n", allGroups.size());
    fflush(stdout);

    return 0;
}
