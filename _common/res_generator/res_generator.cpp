/*
 * RES_Generator - A small resource generator which converts list of files
 * into C++ arrays are can be accessible via friendly functions
 *
 * Copyright (c) 2018-2019 Vitaly Novichkov <admin@wohlnet.ru>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <cstdio>
#include <string>
#include <vector>
#include <ini_processing.h>
#include <utf8main.h>

#ifdef _WIN32
#include <windows.h>
static FILE * utf8_open(const char *path, const char *mode)
{
    wchar_t pathw[MAX_PATH + 1];
    wchar_t modew[MAX_PATH + 1];
    int path_len = strlen(path);
    int mode_len = strlen(mode);
    int pathw_len = MultiByteToWideChar(CP_UTF8, 0, (LPCCH)path, path_len, pathw, MAX_PATH);
    int modew_len = MultiByteToWideChar(CP_UTF8, 0, (LPCCH)mode, mode_len, modew, MAX_PATH);
    pathw[pathw_len] = L'\0';
    modew[modew_len] = L'\0';
    return _wfopen(pathw, modew);
}
#else
#define utf8_open fopen
#endif

static const char* splash = "/*****************************************************************\n"
                            "     Automatically generated by _common/res_generator utility\n"
                            "     Suggested to DONT EDIT THIS\n"
                            "     Edit the _common/res_generator/res_generator.cpp instead\n"
                            " *****************************************************************/\n\n";

struct FileEntry
{
    std::string name;
    std::string path;
    unsigned long size;
};

static int printUsage(char **argv, const char *msg)
{
    printf("%s\n\n"
           "Syntax: %s [--config <ini file name>] <folder that contains \"resource.ini\">\n\n", msg, argv[0]);
    return 1;
}

static int parseTwoArg(const int argc, int &argi, char **argv, const char* key, std::string &out, const char *errmsg)
{
    if(strcmp(argv[argi], key) == 0)
    {
        argi += 1;
        if(argi >= argc)
            return printUsage(argv, errmsg);
        out = argv[argi];
        argi += 1;
        return -1;
    }
    return 0;
}

int main(int argc, char**argv)
{
    IniProcessing ini;

    std::string folderAt = ".";
    std::string iniFile = "resource.ini";
    std::string outputAt = folderAt;
    bool outputWasSet = false;

    std::string headerFile      = "resource.h";
    std::string headerDataFile  = "resource_data.h";
    std::string srcFile         = "resource.cpp";

    if(argc < 2)
    {
        return printUsage(argv, "No path specified!");
    }

    int argi = 1;
    int ret = 0;
    while(argi < argc)
    {
        ret = parseTwoArg(argc, argi, argv, "--config", iniFile, "Missing INI config filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--out-dir", outputAt, "Missing output directory path!");
        if(ret == -1)
        {
            outputWasSet = true;
            continue;
        }
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--header", headerFile, "Missing header filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--data", headerDataFile, "Missing data filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        ret = parseTwoArg(argc, argi, argv, "--src", srcFile, "Missing source filename!");
        if(ret == -1)
            continue;
        if(ret == 1)
            return 1;

        {
            folderAt = argv[argi];
            if(!outputWasSet)
                outputAt = folderAt;
            argi += 1;
            continue;
        }
    }

    printf("== INI config name: %s\n", iniFile.c_str());
    printf("== Output header:   %s\n", headerFile.c_str());
    printf("== Output data:     %s\n", headerDataFile.c_str());
    printf("== Output source:   %s\n", srcFile.c_str());
    printf("== Working folder:  %s\n", folderAt.c_str());
    printf("== Output folder:   %s\n", outputAt.c_str());

    ini.open(folderAt + iniFile);
    unsigned int count = 0;
    ini.beginGroup("resources");
    ini.read("count", count, 0);
    ini.endGroup();

    if(count==0)
    {
        printf("Nothing to do! (zero count)\n");
        return 1;
    }

    std::vector<FileEntry> files;

    for(unsigned int i=0; i<count; i++)
    {
        std::string name;
        std::string path;
        ini.beginGroup("file-" + std::to_string(i));
        ini.read("name", name, "");
        ini.read("path", path, "");
        ini.endGroup();

        files.push_back({name, folderAt + path, 0});
    }

    std::string outH     = outputAt + headerFile;
    std::string outHdata = outputAt + headerDataFile;
    std::string outC     = outputAt + srcFile;
    FILE* outh = utf8_open(outH.c_str(), "wb");
    FILE* outd = utf8_open(outHdata.c_str(), "wb");
    FILE* outc = utf8_open(outC.c_str(), "wb");

    if(!outh || !outd || !outc)
    {
        printf("CAN'T OPEN FILES FOR WRITE\n");
        return 1;
    }

    fprintf(outc, "%s", splash);
    fprintf(outd, "%s", splash);
    fprintf(outh, "%s", splash);

    unsigned int fileCount = 0;

    fprintf(outc,   "#include <stdio.h>\n"
                    "#include <string>\n"
                    "#include \"%s\"\n"
                    "#include \"%s\"\n"
                    "\n",
            headerDataFile.c_str(),
            headerFile.c_str());

    fprintf(outd,   "#include <unordered_map>\n\n"
                    "struct FileEntry{\n"
                    "   unsigned char*array;\n"
                    "   size_t size;\n"
                    "};\n\n");

    for(size_t i = 0; i < files.size(); i++, fileCount++)
    {
        FileEntry& it = files[i];
        fprintf(outd,   "// %s\n"
                        "static unsigned char file_%d[] =\n"
                        "{\n    ", it.name.c_str(), fileCount);
        FILE* ps = utf8_open(it.path.c_str(), "rb");
        if(!ps)
        {
            printf("FAILED TO OPEN FILE %s\n", it.path.c_str());
            continue;
        }
        int c;
        int breaker = 0;
        unsigned long fileSize = 0;
        while((c = fgetc(ps)) != -1)
        {
            fprintf(outd, " 0x%02X,", static_cast<unsigned int>(c));
            fileSize++;
            breaker++;
            if(breaker >= 10)
            {
                fprintf(outd, "\n    ");
                breaker = 0;
            }
        }
        fprintf(outd, " 0x00");
        fclose(ps);
        it.size = fileSize;
        fprintf(outd, "\n};\n\n");
    }

    fprintf(outd,   "// List of availalbe resource files\n"
                    "static std::unordered_map<std::string, FileEntry> filesMap =\n"
                    "{\n");
    for(size_t i = 0; i < files.size(); i++, fileCount++)
    {
        FileEntry& it = files[i];
        fprintf(outd, "    {\"%s\",\t{file_%lu,%8lu}},\n", it.name.c_str(), (unsigned long)i, it.size);
    }
    fprintf(outd, "};\n\n");

    /*
    fprintf(outc,   "FILE* RES_open(const char* file)\n{\n"
                    "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
                    "   if(f == filesMap.end())\n"
                    "       return nullptr;\n\n"
                    "   FileEntry& e = f->second;\n"
                    "   return fmemopen(reinterpret_cast<void*>(const_cast<unsigned char*>(e.array)), e.size, \"rb\");\n"
                    "}\n\n");
    */ //Windows OS is totally sucks because fmemopen() isn't implemented on the kernel

    fprintf(outc,   "bool RES_getMem(const char* file, unsigned char* &mem, size_t &size)\n{\n"
                    "   std::unordered_map<std::string, FileEntry>::iterator f = filesMap.find(file);\n"
                    "   if(f == filesMap.end())\n"
                    "       return false;\n\n"
                    "   FileEntry& e = f->second;\n"
                    "   mem = e.array;\n"
                    "   size = e.size;\n"
                    "   return true;\n"
                    "}\n\n");

    fprintf(outh, "#include <stdio.h>\n\n");
    //fprintf(outh, "extern FILE* RES_open(const char* file);\n");
    fprintf(outh,   "/**\n"
                    " * @brief Get memory pointer and block size to resource file\n"
                    " * @param [IN] file name of resource file\n"
                    " * @param [OUT] mem reference to null pointer\n"
                    " * @param [OUT] size reference to size variable\n"
                    " */\n"
                    "extern bool RES_getMem(const char* file, unsigned char* &mem, size_t &size);\n\n");

    fclose(outh);
    fclose(outc);

    printf("All %d resources has been packed!\n", count);

    return 0;
}

